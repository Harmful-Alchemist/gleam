<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Test wasm</title>
<!--    <script src="thuh.js"></script>-->
    <script>
        const importObject = {
            // imports: {imported_func: (arg) => console.log(arg)}, Aah with a different module can make a map of functions to names and put that in imports, the imports name is not special! Could put the gleam mjs there but(!) then tie it to js...
            imports: {"console.log": console.log } //So this works and we can get it... But is annoying we have to call outside.....
            // But how else are you going to do I/O, wasi https://wasi.dev/ ?
            // Browser polyfill: https://github.com/bjorn3/browser_wasi_shim ? Meh. Well maybe the meh is that you have to use it,
            // could still provide a nice way to do gleam/io maybe? But I'd say  @external with something we have now could be good too, easier anyway!

            // Or re-use the mjs: https://github.com/gleam-lang/stdlib/blob/main/src/gleam_stdlib.mjs#L294 ??? That'd be fun and allow one by one rewrite?
            // interesting: https://github.com/gleam-lang/stdlib/blob/main/src/gleam/io.gleam#L21

            // Tho "At the WebAssembly level, WASI is just a set of callable functions that can be imported by a .wasm module,
            // and these imports can be implemented in a variety of ways,
            // including by a JavaScript polyfill library running within browsers."

            // Aaah Strings in Gleam just UTF-8 see stdlib

        };

        WebAssembly.instantiateStreaming(fetch("compiler-core/letstry.wasm")).then(
            (obj) => {
                let ans = obj.instance.exports.add(1, 2);
                console.log(ans);
                document.getElementById("answer").textContent = ans;
            },
        );

        WebAssembly.instantiateStreaming(fetch("trying_some.wasm"), importObject).then(
            (obj) => {
                obj.instance.exports.log();
                console.log("ok... done? 42 above?");
            },
        );

        WebAssembly.instantiateStreaming(fetch("trying_some_typing.wasm")).then(
            (obj) => {
                let ans = obj.instance.exports.lessee();
                document.getElementById("answer_type").textContent = ans;
            },
        );


        // Prolly is a red herring but arrays & structs are in the Store, which has memory but also arrays structs etc. So we'll see.
        const memory = new WebAssembly.Memory({
            initial: 10,
            maximum: 100,
        });

        WebAssembly.instantiateStreaming(fetch("trying_some_arrays.wasm"), {
            js: { mem: memory }}).then(
            (obj) => {
                // const summands = new Uint32Array(memory.buffer);
                // console.log(memory.buffer);

                //TODO not sure of wasm needs to use this memory, prolly with import... And Besides WebAssembly.Memory we have WebAssembly.Table. Maybe a extra type for the heap? structs/arrays?
                // exports then hmmmmmmmmmmmmmmmmmmmmmmmmmm

                let ans = obj.instance.exports.lol();
                let access = obj.instance.exports.accessing(ans,2);

                // let ans = obj.instance.exports.lol(new ArrayBuffer(12));
                // console.log(memory.buffer);
                // let x = new Uint32Array(memory.buffer).filter(x => x!==0) //Empty!
                // console.log(x);
                // console.log(obj);
                console.log(ans); //An object with no properties... So hmmmmmmmmmmmmm. In firefox an empty WasmArrayObject, but I see no way to access it
                // console.log(ans.numElements_); //undefined.
                document.getElementById("array_index").textContent = access;
                document.getElementById("array").textContent = JSON.stringify(ans);
            },
        );
    </script>
</head>
<body>

<p>python -m http.server 8001</p>
<p>http://0.0.0.0:8001/testing.html</p>

$> 1+2 =
<div id="answer"></div>
<br>
<br>
Playing with types:
<div id="answer_type"></div>
<br>
<br>
<h3>Playing with arrays:</h3>
<br>
Whole:
<div id="array"></div>
<br>
At index:
<div id="array_index"></div>
</body>
</html>